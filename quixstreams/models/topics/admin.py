import logging
import pprint
import time
from asyncio import Future
from typing import List, Dict, Mapping, Optional

from confluent_kafka.admin import (
    AdminClient,
    ConfigResource,
    KafkaException,  # type: ignore
    NewTopic as ConfluentTopic,  # type: ignore
    TopicMetadata as ConfluentTopicMetadata,
)

from .exceptions import CreateTopicFailure, CreateTopicTimeout
from .topic import Topic, TopicConfig

logger = logging.getLogger(__name__)

__all__ = ("TopicAdmin",)


def convert_topic_list(topics: List[Topic]) -> List[ConfluentTopic]:
    """
    Converts `Topic`s to `ConfluentTopic`s as required for Confluent's
    `AdminClient.create_topic()`.

    :param topics: list of `Topic`s
    :return: list of confluent_kafka `ConfluentTopic`s
    """
    return [
        ConfluentTopic(
            topic=topic.name,
            num_partitions=topic.config.num_partitions,
            replication_factor=topic.config.replication_factor,
            config=topic.config.extra_config,
        )
        for topic in topics
    ]


def confluent_topic_config(topic: str) -> ConfigResource:
    return ConfigResource(2, topic)


class TopicAdmin:
    """
    For performing "admin"-level operations on a Kafka cluster, mostly around topics.

    Primarily used to create and inspect topic configurations.
    """

    def __init__(
        self,
        broker_address: str,
        extra_config: Optional[Mapping] = None,
    ):
        """
        :param broker_address: the address for the broker
        :param extra_config: optional configs (generally accepts producer configs)
        """
        self._inner_admin: Optional[AdminClient] = None
        self._config = {
            "bootstrap.servers": broker_address,
            **(extra_config or {}),
        }

    @property
    def _admin_client(self) -> AdminClient:
        if not self._inner_admin:
            self._inner_admin = AdminClient(self._config)
        return self._inner_admin

    def list_topics(self) -> Dict[str, ConfluentTopicMetadata]:
        """
        Get a list of topics and their metadata from a Kafka cluster

        :return: a dict of topic names and their metadata objects
        """
        # TODO: allow filtering based on a prefix ignore list?
        return self._admin_client.list_topics().topics

    def inspect_topics(
        self, topic_names: List[str]
    ) -> Dict[str, Optional[TopicConfig]]:
        """
        A simplified way of getting the topic configurations of the provided topics
        from the cluster (if they exist).

        :param topic_names: a list of topic names
        :return: a dict with topic names and their respective `TopicConfig`
        """
        futures_dict = {}
        cluster_topics = self.list_topics()
        if existing_topics := [
            topic for topic in topic_names if topic in cluster_topics
        ]:
            futures_dict = self._admin_client.describe_configs(
                [confluent_topic_config(topic) for topic in existing_topics]
            )
        configs = {
            config_resource.name: {c.name: c.value for c in config.result().values()}
            for config_resource, config in futures_dict.items()
        }
        return {
            topic: TopicConfig(
                num_partitions=len(cluster_topics[topic].partitions),
                replication_factor=len(cluster_topics[topic].partitions[0].replicas),
                extra_config=configs[topic],
            )
            if topic in existing_topics
            else None
            for topic in topic_names
        }

    def _finalize_create(self, futures: Dict[str, Future], timeout: int):
        """
        The confirmation step for topic creation.

        :param futures: a dict of futures as generated by Confluent's
            `AdminClient.create_topics()`
        :param timeout: How long to confirm topics before raising exception
        """
        exceptions = {}
        successful = []
        existed = []
        stop_time = time.time() + timeout
        while futures and time.time() < stop_time:
            time.sleep(1)
            for topic_name in list(futures.keys()):
                future = futures[topic_name]
                if future.done():
                    try:
                        future.result()
                        successful.append(topic_name)
                    except KafkaException as e:
                        # Topic was maybe created by another instance
                        if e.args[0].name() == "TOPIC_ALREADY_EXISTS":
                            existed.append(topic_name)
                        else:
                            exceptions[topic_name] = e.args[0].str()
                    # Not sure how these get raised, but they are supposedly possible
                    except (TypeError, ValueError) as e:
                        exceptions[topic_name] = e
                    del futures[topic_name]
        if successful:
            logger.info(f"Successfully created topics: {successful}")
        if existed:
            logger.info(f"These topics already exist: {existed}")
        if exceptions:
            raise CreateTopicFailure(exceptions)
        if futures:
            raise CreateTopicTimeout(
                f"Timed out waiting for creation status for topics:\n"
                f"{pprint.pformat([topic_name for topic_name in futures])}"
            )

    def create_topics(
        self, topics: List[Topic], timeout: int = 10, finalize_timeout: int = 20
    ):
        """
        Create the given list of topics and confirm they are ready.

        Also raises an exception with detailed printout should the creation
        fail (it ignores issues for a topic already existing).

        :param topics: a list of `Topic`
        :param timeout: timeout of the creation broker request
        :param finalize_timeout: the timeout of the topic finalizing ("ready")
        """
        existing = self.list_topics().keys()
        if not (topics := [topic for topic in topics if topic.name not in existing]):
            logger.info("All topics already exist!")
            return
        try:
            self._finalize_create(
                self._admin_client.create_topics(
                    convert_topic_list(topics),
                    request_timeout=timeout,
                ),
                finalize_timeout,
            )
        except CreateTopicFailure as e:
            failure = {
                topic.name: {
                    "failure_reason": e.args[0][topic.name],
                    "topic_config": topic.config.__dict__,
                }
                for topic in topics
                if topic.name in e.args[0]
            }
            raise CreateTopicFailure(
                f"failed to create topics:\n{pprint.pformat(failure)}"
            )
